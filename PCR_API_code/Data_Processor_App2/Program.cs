// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// THIS PROJECT IS NOT A PART OF THE DEFAULT BIORAD API
// THE FOLLOWING CODE READS THE DATA GENERATED BY THE PCR RUN AND CREATES A CONSOLIDATED RESULT FILE IN JSON FORMAT
// TO COMPILE THE FOLLOWING CODE, YOU NEED TO INSTALL "CSVHELPER v15.0.5" AND "NEWTONSOFT.JSON v12.0.3" from NuGET PACKAGE MANAGER
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
// $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Data;
using System.Diagnostics;
using CsvHelper;
using CsvHelper.Configuration;
using CsvHelper.Configuration.Attributes;
using System.Globalization;
using Newtonsoft;
using Newtonsoft.Json;

namespace PCR_Data_Processor
{
    class Data_PrimerDesign
    {
        public string labName, username, plateBarcode, pcrSerial, runDate, runTime, testKitName;
        public string[] fluorophores = new string[2];
        public int numCycles, numWells;
        public Control_PrimerDesign NEC_PCT_results;
        public List<Well_PrimerDesign> Wells = new List<Well_PrimerDesign>();

        public Data_PrimerDesign(int num_cycles, int num_wells)
        {
            labName = "Calcinate Lab"; username = "JohnSmith"; plateBarcode = "default"; pcrSerial = "PCR_SERIAL"; runDate = "default";
            runTime = "default"; testKitName = "Primerdesign Ltd COVID-19"; fluorophores[0] = "HEX"; fluorophores[1] = "FAM";
            numCycles = num_cycles; numWells = num_wells;
        }
    }

    class Well_PrimerDesign
    {
        public string wellNum, wellContent;
        int numCycles;
        public string hexCq, famCq;
        public float hexRFU_endpoint, famRFU_endpoint;
        public string test_call;
        public float[] hexRFU_points, famRFU_points;

        public Well_PrimerDesign(int num_cycles)
        {
            wellNum = "A1"; wellContent = "Unknown"; numCycles = num_cycles; hexCq = "NaN"; famCq = "NaN"; test_call = "(-) neg";
            hexRFU_endpoint = 0; famRFU_endpoint = 0;
            hexRFU_points = new float[num_cycles];
            famRFU_points = new float[num_cycles];
            for (int i = 0; i < num_cycles; i++)
            {
                hexRFU_points[i] = 0;
                famRFU_points[i] = 0;
            }
        }
    }

    class Control_PrimerDesign
    {
        public string NEC_hexCq, PCT_hexCq, NEC_famCq, PCT_famCq;
        public float NEC_hexRFU_endpoint, PCT_hexRFU_endpoint, NEC_famRFU_endpoint, PCT_famRFU_endpoint;
        public string NECresult, PCTresult;

        public Control_PrimerDesign()
        {
            NEC_hexCq = "NaN"; PCT_hexCq = "NaN"; NEC_famCq = "NaN"; PCT_famCq = "NaN";
            NEC_hexRFU_endpoint = 0; PCT_hexRFU_endpoint = 0; NEC_famRFU_endpoint = 0; PCT_famRFU_endpoint = 0;
            NECresult = "SUCCESS"; PCTresult = "SUCCESS";
        }
    }

    class Data_AllPlex
    {
        public string labName, username, plateBarcode, pcrSerial, runDate, runTime, testKitName;
        public string[] fluorophores = new string[4];
        public int numCycles, numWells;
        public Control_AllPlex NEC_PCT_results;
        public List<Well_AllPlex> Wells = new List<Well_AllPlex>();

        public Data_AllPlex(int num_cycles, int num_wells)
        {
            labName = "Calcinate Lab"; username = "JohnSmith"; plateBarcode = "default"; pcrSerial = "PCR_SERIAL"; runDate = "default";
            runTime = "default"; testKitName = "AllPlex SARS-CoV-2"; fluorophores[0] = "HEX"; fluorophores[1] = "FAM"; fluorophores[2] = "Cal Red 610";
            fluorophores[3] = "Quasar 670";
            numCycles = num_cycles; numWells = num_wells;
        }
    }

    class Well_AllPlex
    {
        public string wellNum, wellContent;
        int numCycles;
        public string hexCq, famCq, cr610Cq, qua670Cq;
        public float hexRFU_endpoint, famRFU_endpoint, cr610RFU_endpoint, qua670RFU_endpoint;
        public string test_call;
        public float[] hexRFU_points, famRFU_points, cr610RFU_points, qua670RFU_points;

        public Well_AllPlex(int num_cycles)
        {
            wellNum = "A1"; wellContent = "Unknown"; numCycles = num_cycles; hexCq = "NaN"; famCq = "NaN"; cr610Cq = "NaN"; qua670Cq = "NaN";
            test_call = "(-) neg";
            hexRFU_endpoint = 0; famRFU_endpoint = 0; cr610RFU_endpoint = 0; qua670RFU_endpoint = 0;
            hexRFU_points = new float[num_cycles];
            famRFU_points = new float[num_cycles];
            cr610RFU_points = new float[num_cycles];
            qua670RFU_points = new float[num_cycles];
            for (int i = 0; i < num_cycles; i++)
            {
                hexRFU_points[i] = 0;
                famRFU_points[i] = 0;
                cr610RFU_points[i] = 0;
                qua670RFU_points[i] = 0;
            }
        }
    }

    class Control_AllPlex
    {
        public string NEC_hexCq, PCT_hexCq, NEC_famCq, PCT_famCq, NEC_cr610Cq, PCT_cr610Cq, NEC_qua670Cq, PCT_qua670Cq;
        public float NEC_hexRFU_endpoint, PCT_hexRFU_endpoint, NEC_famRFU_endpoint, PCT_famRFU_endpoint;
        public float NEC_cr610RFU_endpoint, PCT_cr610RFU_endpoint, NEC_qua670RFU_endpoint, PCT_qua670RFU_endpoint;
        public string NECresult, PCTresult;

        public Control_AllPlex()
        {
            NEC_hexCq = "NaN"; PCT_hexCq = "NaN"; NEC_famCq = "NaN"; PCT_famCq = "NaN";
            NEC_cr610Cq = "NaN"; PCT_cr610Cq = "NaN"; NEC_qua670Cq = "NaN"; PCT_qua670Cq = "NaN";
            NEC_hexRFU_endpoint = 0; PCT_hexRFU_endpoint = 0; NEC_famRFU_endpoint = 0; PCT_famRFU_endpoint = 0;
            NEC_cr610RFU_endpoint = 0; PCT_cr610RFU_endpoint = 0; NEC_qua670RFU_endpoint = 0; PCT_qua670RFU_endpoint = 0;
            NECresult = "SUCCESS"; PCTresult = "SUCCESS";
        }
    }

    class Data_KHB
    {
        public string labName, username, plateBarcode, pcrSerial, runDate, runTime, testKitName;
        public string[] fluorophores = new string[4];
        public int numCycles, numWells;
        public Control_KHB NEC_PCT_results;
        public List<Well_KHB> Wells = new List<Well_KHB>();

        public Data_KHB(int num_cycles, int num_wells)
        {
            labName = "Calcinate Lab"; username = "JohnSmith"; plateBarcode = "default"; pcrSerial = "PCR_SERIAL"; runDate = "default";
            runTime = "default"; testKitName = "KHB SARS-CoV-2"; fluorophores[0] = "HEX"; fluorophores[1] = "FAM"; fluorophores[2] = "ROX";
            fluorophores[3] = "Cy5";
            numCycles = num_cycles; numWells = num_wells;
        }
    }

    class Well_KHB
    {
        public string wellNum, wellContent;
        int numCycles;
        public string hexCq, famCq, roxCq, cy5Cq;
        public float hexRFU_endpoint, famRFU_endpoint, roxRFU_endpoint, cy5RFU_endpoint;
        public string test_call;
        public float[] hexRFU_points, famRFU_points, roxRFU_points, cy5RFU_points;

        public Well_KHB(int num_cycles)
        {
            wellNum = "A1"; wellContent = "Unknown"; numCycles = num_cycles; hexCq = "NaN"; famCq = "NaN"; roxCq = "NaN"; cy5Cq = "NaN";
            test_call = "(-) neg";
            hexRFU_endpoint = 0; famRFU_endpoint = 0; roxRFU_endpoint = 0; cy5RFU_endpoint = 0;
            hexRFU_points = new float[num_cycles];
            famRFU_points = new float[num_cycles];
            roxRFU_points = new float[num_cycles];
            cy5RFU_points = new float[num_cycles];
            for (int i = 0; i < num_cycles; i++)
            {
                hexRFU_points[i] = 0;
                famRFU_points[i] = 0;
                roxRFU_points[i] = 0;
                cy5RFU_points[i] = 0;
            }
        }
    }

    class Control_KHB
    {
        public string NEC_hexCq, PCT_hexCq, NEC_famCq, PCT_famCq, NEC_roxCq, PCT_roxCq, NEC_cy5Cq, PCT_cy5Cq;
        public float NEC_hexRFU_endpoint, PCT_hexRFU_endpoint, NEC_famRFU_endpoint, PCT_famRFU_endpoint;
        public float NEC_roxRFU_endpoint, PCT_roxRFU_endpoint, NEC_cy5RFU_endpoint, PCT_cy5RFU_endpoint;
        public string NECresult, PCTresult;

        public Control_KHB()
        {
            NEC_hexCq = "NaN"; PCT_hexCq = "NaN"; NEC_famCq = "NaN"; PCT_famCq = "NaN";
            NEC_roxCq = "NaN"; PCT_roxCq = "NaN"; NEC_cy5Cq = "NaN"; PCT_cy5Cq = "NaN";
            NEC_hexRFU_endpoint = 0; PCT_hexRFU_endpoint = 0; NEC_famRFU_endpoint = 0; PCT_famRFU_endpoint = 0;
            NEC_roxRFU_endpoint = 0; PCT_roxRFU_endpoint = 0; NEC_cy5RFU_endpoint = 0; PCT_cy5RFU_endpoint = 0;
            NECresult = "SUCCESS"; PCTresult = "FAIL";
        }
    }


    public class DataProcess //THIS IS THE FUNCTION THAT IS CALLED FROM MainForm.cs
    {
        public static string csvFilesFolder = @"C:\PCR_BioRad\csv_results";
        public static string jsonResultFileFolder = @"C:\PCR_BioRad\json_results";
        public static string pcrdResultFolder = @"C:\PCR_BioRad\pcrd_results";
        public static string[] PCRserials = new string[8] { "CT046020", "CT043770", "CT044263", "CT044190",
                                                           "BR202310", "BR202290", "BR202316", "BR202342" }; // Serials of PCRs in the lab
        public static string[] PCRaliases = new string[8] { "PCR 1", "PCR 2", "PCR 3", "PCR 4", "PCR DX 1",
                                                          "PCR DX 2", "PCR DX 3", "PCR DX 4" }; // Aliases of PCRs. Make sure that the Serials
                                                                                                // and Aliases of the PCR are in the same order
                                                                                                // example: "CT046020" has the alias "PCR 1"
        public static string[] testResultFolder = new string[4] { @"C:\Users\Admin\OneDrive\Desktop\BIO RAD\TEST RESULTS",
                                                                  @"C:\Users\Bio-Rad\OneDrive\Desktop\BIO RAD\TEST RESULTS",
                                                                  @"C:\Utenti\Admin\OneDrive\Desktop\BIO RAD\TEST RESULTS",
                                                                  @"C:\Utenti\Bio-Rad\OneDrive\Desktop\BIO RAD\TEST RESULTS"};
                                                                  // HERE IS A LIST OF ONE-DRIVE DIRECTORIES FOR SAVING THE .pcrd FILES

        public static void process_data(string PCRserial, string outputFileName)
        {
            bool hexCheck = false, famCheck = false, roxCheck = false, cy5Check = false, cr610Check = false, qua670Check = false;
            string fileNameSubstring = outputFileName + " -  Quantification Amplification*.csv";
            string[] ampliFiles = Directory.GetFiles(csvFilesFolder, fileNameSubstring);

            for (int i = 0; i < ampliFiles.Length; i++)
            {
                if (ampliFiles[i].IndexOf("HEX") != -1)
                    hexCheck = true;
                if (ampliFiles[i].IndexOf("FAM") != -1)
                    famCheck = true;
                if (ampliFiles[i].IndexOf("ROX") != -1)
                    roxCheck = true;
                if (ampliFiles[i].IndexOf("Cy5") != -1)
                    cy5Check = true;
                if (ampliFiles[i].IndexOf("Cal Red 610") != -1)
                    cr610Check = true;
                if (ampliFiles[i].IndexOf("Quasar 670") != -1)
                    qua670Check = true;
            }

            if (hexCheck && famCheck && roxCheck && cy5Check)
                process_data_KHB(PCRserial, outputFileName);
            else if (hexCheck && famCheck && cr610Check && qua670Check)
                process_data_AllPlex(PCRserial, outputFileName);
            else if (hexCheck && famCheck)
                process_data_PrimerDesign(PCRserial, outputFileName);

            copy_to_OneDrive(PCRserial, outputFileName);

        }

        public static void copy_to_OneDrive(string PCRserial, string outputFileName) // FUNCTION FOR COPYING THE .pcrd FILES TO A ONE-DRIVE FOLDER
        {
            string pcrdFileName = outputFileName + ".pcrd";
            string sourceFilePath = Path.Combine(pcrdResultFolder, pcrdFileName);
            string targetFolder = string.Empty;
            string targetFilePath = string.Empty;
            int index = 0;

            for (int i = 0; i < PCRserials.Length; i++)
                if (PCRserial == PCRserials[i])
                    index = i;
            
            for (int i = 0; i < testResultFolder.Length; i++)
            {
                if (Directory.Exists(testResultFolder[i]))
                {
                    targetFolder = Path.Combine(testResultFolder[i], PCRaliases[index]);
                    if (Directory.Exists(targetFolder) && File.Exists(sourceFilePath))
                    {
                        targetFilePath = Path.Combine(targetFolder, pcrdFileName);
                        File.Copy(sourceFilePath, targetFilePath, false);
                    }
                }
            }
        }





        static void process_data_PrimerDesign(string PCRserial, string outputFileName)
        {
            Data_PrimerDesign pcrRunData;
            int numCycles, numWells, count = 0, count1 = 0, NECindex = 0, PCTindex = 9;
            float tf1, tf2;
            DataTable FAMtable = new DataTable();
            DataTable HEXtable = new DataTable();
            DataTable CQtable = new DataTable();
            string ampFileSubstring = outputFileName + " -  Quantification Amplification*.csv";
            string[] ampFilePaths = Directory.GetFiles(csvFilesFolder, ampFileSubstring);
            string CqFileSubstring = outputFileName + " -  Quantification Cq*.csv";
            string[] CqFilePath = Directory.GetFiles(csvFilesFolder, CqFileSubstring);
            string[] CqFAM, CqHEX;
            string jsonText, tempFilePath = ampFilePaths[0];
            string jsonResultFileName = string.Format("{0}_{1}_{2}", PCRserial, outputFileName, "Result.json");
            string jsonResultFilePath = Path.Combine(jsonResultFileFolder, jsonResultFileName);

            //LOADING THE CQ TABLE - START ------------------------------------------------------------------------
            using (var reader = new StreamReader(CqFilePath[0]))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    CQtable.Load(dr);
                }
            }
            foreach (DataColumn column in CQtable.Columns)
            {
                column.ReadOnly = false;
            }
            numWells = CQtable.Rows.Count / 2;
            CqFAM = new string[numWells];
            CqHEX = new string[numWells];

            count = 0; count1 = 0;
            for (int i = 0; i < CQtable.Rows.Count; i++)
            {
                if (CQtable.Rows[i][7].ToString() != "NaN")
                {
                    tf1 = Convert.ToSingle(CQtable.Rows[i][7].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    CQtable.Rows[i][7] = tf1.ToString();
                }
                if (CQtable.Rows[i][2].ToString() == "FAM")
                {
                    CqFAM[count] = CQtable.Rows[i][7].ToString();
                    ++count;
                }
                if (CQtable.Rows[i][2].ToString() == "HEX")
                {
                    CqHEX[count1] = CQtable.Rows[i][7].ToString();
                    ++count1;
                }
            }

            for (int i = 0; i < numWells; i++)
            {
                if (CQtable.Rows[i][4].ToString() == "Neg Ctrl")
                    NECindex = i;
                if (CQtable.Rows[i][4].ToString() == "Pos Ctrl")
                    PCTindex = i;
            }
            //LOADING THE CQ TABLE - END --------------------------------------------------------------------------

            //LOADING THE FAM AMPLIFICATION TABLE  - START --------------------------------------------------------
            for (int i = 0; i < ampFilePaths.Length; i++)
                if (ampFilePaths[i].IndexOf("FAM") != -1)
                    tempFilePath = ampFilePaths[i];
            using (var reader = new StreamReader(tempFilePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    FAMtable.Load(dr);
                }
            }
            foreach (DataColumn column in FAMtable.Columns)
            {
                column.ReadOnly = false;
            }
            numCycles = FAMtable.Rows.Count;

            for (int i = 0; i < numCycles; i++)
            {
                for (int j = 2; j < FAMtable.Columns.Count; j++)
                {
                    tf1 = Convert.ToSingle(FAMtable.Rows[i][j].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    FAMtable.Rows[i][j] = tf1.ToString(); //FAM RFU values
                }
            }
            //LOADING THE FAM AMPLIFICATION TABLE - END ------------------------------------------------------------

            //LOADING THE HEX AMPLIFICATION TABLE  - START ---------------------------------------------------------
            for (int i = 0; i < ampFilePaths.Length; i++)
                if (ampFilePaths[i].IndexOf("HEX") != -1)
                    tempFilePath = ampFilePaths[i];
            using (var reader = new StreamReader(tempFilePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    HEXtable.Load(dr);
                }
            }
            foreach (DataColumn column in HEXtable.Columns)
            {
                column.ReadOnly = false;
            }

            for (int i = 0; i < numCycles; i++)
            {
                for (int j = 2; j < HEXtable.Columns.Count; j++)
                {
                    tf1 = Convert.ToSingle(HEXtable.Rows[i][j].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    HEXtable.Rows[i][j] = tf1.ToString(); //HEX RFU values
                }
            }
            //LOADING THE HEX AMPLIFICATION TABLE - END ------------------------------------------------------------

            //CREATING THE OBJECT OF Data_PrimerDesign AND Well_PrimerDesign WITH ALL THE TEST DATA - START --------
            pcrRunData = new Data_PrimerDesign(numCycles, numWells);
            pcrRunData.NEC_PCT_results = new Control_PrimerDesign();
            Control_PrimerDesign control = new Control_PrimerDesign();
            pcrRunData.pcrSerial = PCRserial;
            pcrRunData.runDate = outputFileName.Substring(5, 10);
            pcrRunData.runTime = outputFileName.Substring(16, 8);
            control.NEC_hexCq = CqHEX[NECindex]; control.PCT_hexCq = CqHEX[PCTindex];
            control.NEC_famCq = CqFAM[NECindex]; control.PCT_famCq = CqFAM[PCTindex];

            tf1 = (Convert.ToSingle(HEXtable.Rows[numCycles - 1][NECindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 2][NECindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 3][NECindex + 2])) / 3;
            control.NEC_hexRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(HEXtable.Rows[numCycles - 1][PCTindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 2][PCTindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 3][PCTindex + 2])) / 3;
            control.PCT_hexRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(FAMtable.Rows[numCycles - 1][NECindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 2][NECindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 3][NECindex + 2])) / 3;
            control.NEC_famRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(FAMtable.Rows[numCycles - 1][PCTindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 2][PCTindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 3][PCTindex + 2])) / 3;
            control.PCT_famRFU_endpoint = (float)Math.Round(tf1, 2);

            //-----PCT and NEC test results logic - by default the PCT and NEC results are considered "SUCCESS"
            if (control.NEC_hexCq == "NaN") //NEC fails if no amplification is found in HEX
                control.NECresult = "FAIL";
            else if (Convert.ToSingle(control.NEC_hexCq) > 30) //NEC fails if hex Cq is more than 30
                control.NECresult = "FAIL";
            if (control.NEC_famCq != "NaN") //NEC fails if amplification is found in FAM
                if (control.NEC_famRFU_endpoint >= 999)
                    control.NECresult = "FAIL";

            if (control.PCT_famCq == "NaN") //PCT fails if no amplification is found in FAM
                control.PCTresult = "FAIL";
            else if (control.PCT_famRFU_endpoint < 999) // PCT fails if the endpoint RFU value in FAM is too low
                control.PCTresult = "FAIL";

            for (int i = 0; i < numWells; i++) // loop for creating and initializing all wells
                pcrRunData.Wells.Add(new Well_PrimerDesign(numCycles));

            count = 0;
            foreach (Well_PrimerDesign aWell in pcrRunData.Wells) // loop for transfering data into well objects list
            {
                aWell.wellNum = CQtable.Rows[count][1].ToString();
                aWell.wellContent = CQtable.Rows[count][4].ToString();
                aWell.hexCq = CqHEX[count];
                aWell.famCq = CqFAM[count];

                tf1 = (Convert.ToSingle(HEXtable.Rows[numCycles - 1][count + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 2][count + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 3][count + 2])) / 3;
                aWell.hexRFU_endpoint = (float)Math.Round(tf1, 2);

                tf1 = (Convert.ToSingle(FAMtable.Rows[numCycles - 1][count + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 2][count + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 3][count + 2])) / 3;
                aWell.famRFU_endpoint = (float)Math.Round(tf1, 2);

                for (int i = 0; i < numCycles; i++)
                {
                    aWell.hexRFU_points[i] = Convert.ToSingle(HEXtable.Rows[i][count + 2]);
                    aWell.famRFU_points[i] = Convert.ToSingle(FAMtable.Rows[i][count + 2]);
                }

                //-----test call logic for each well - by default, the well sample is considered a "(-) neg"
                if (control.NECresult == "FAIL" || control.PCTresult == "FAIL") //test is inconc. if PCT or NEC fails
                    aWell.test_call = "Inconclusive";
                else
                {
                    if (aWell.famCq != "NaN") // test is positive if there is amplification in FAM
                        if (aWell.famRFU_endpoint >= 999)
                            aWell.test_call = "(+) POSITIVE";
                    if (aWell.hexCq == "NaN" && aWell.famCq == "NaN") //test is inconc. if no amplification in both HEX and FAM
                        aWell.test_call = "Inconclusive";
                    else if (aWell.hexCq != "NaN")
                    {
                        tf1 = Convert.ToSingle(aWell.hexCq);
                        tf2 = Convert.ToSingle(control.NEC_hexCq);
                        if (tf1 > tf2 + 6) // test is inconc. if HEX Cq is more than NEC HEX Cq + 6
                            aWell.test_call = "Inconclusive";
                    }
                }
                ++count;
            }
            pcrRunData.NEC_PCT_results = control;
            //CREATING THE OBJECT OF Data_PrimerDesign AND Well_PrimerDesign WITH ALL THE TEST DATA - END ------------------


            //WRITING THE JSON FILE - START --------------------------------------------------------------------------
            jsonText = JsonConvert.SerializeObject(pcrRunData, Formatting.Indented);
            File.WriteAllText(jsonResultFilePath, jsonText, Encoding.UTF8);
            //WRITING THE JSON FILE - END ----------------------------------------------------------------------------


            //DELETING THE CSV FILES AND CLEARING THE TABLES - START -------------------------------------------------
            string[] filePaths = Directory.GetFiles(csvFilesFolder, "*.csv");
            for (int i = 0; i < filePaths.Length; i++)
                File.Delete(filePaths[i]);
            HEXtable.Clear();
            FAMtable.Clear();
            CQtable.Clear();
            //DELETING THE CSV FILES AND CLEARING THE TABLES - END ----------------------------------------------------
        }








        static void process_data_AllPlex(string PCRserial, string outputFileName)
        {
            Data_AllPlex pcrRunData;
            int numCycles, numWells, count = 0, count1 = 0, count2 = 0, count3 = 0, NECindex = 0, PCTindex = 9;
            float tf1, tf2, tf3;
            DataTable FAMtable = new DataTable();
            DataTable HEXtable = new DataTable();
            DataTable CR610table = new DataTable();
            DataTable Qua670table = new DataTable();
            DataTable CQtable = new DataTable();
            string ampFileSubstring = outputFileName + " -  Quantification Amplification*.csv";
            string[] ampFilePaths = Directory.GetFiles(csvFilesFolder, ampFileSubstring);
            string CqFileSubstring = outputFileName + " -  Quantification Cq*.csv";
            string[] CqFilePath = Directory.GetFiles(csvFilesFolder, CqFileSubstring);
            string[] CqFAM, CqHEX, CqCR610, CqQua670;
            string jsonText, tempFilePath = ampFilePaths[0];
            string jsonResultFileName = string.Format("{0}_{1}_{2}", PCRserial, outputFileName, "Result.json");
            string jsonResultFilePath = Path.Combine(jsonResultFileFolder, jsonResultFileName);

            //LOADING THE CQ TABLE - START ------------------------------------------------------------------------
            using (var reader = new StreamReader(CqFilePath[0]))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    CQtable.Load(dr);
                }
            }
            foreach (DataColumn column in CQtable.Columns)
            {
                column.ReadOnly = false;
            }
            numWells = CQtable.Rows.Count / 4;
            CqFAM = new string[numWells];
            CqHEX = new string[numWells];
            CqCR610 = new string[numWells];
            CqQua670 = new string[numWells];

            count = 0; count1 = 0; count2 = 0; count3 = 0;
            for (int i = 0; i < CQtable.Rows.Count; i++)
            {
                if (CQtable.Rows[i][7].ToString() != "NaN")
                {
                    tf1 = Convert.ToSingle(CQtable.Rows[i][7].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    CQtable.Rows[i][7] = tf1.ToString();
                }
                if (CQtable.Rows[i][2].ToString() == "FAM")
                {
                    CqFAM[count] = CQtable.Rows[i][7].ToString();
                    ++count;
                }
                if (CQtable.Rows[i][2].ToString() == "HEX")
                {
                    CqHEX[count1] = CQtable.Rows[i][7].ToString();
                    ++count1;
                }
                if (CQtable.Rows[i][2].ToString() == "Cal Red 610")
                {
                    CqCR610[count2] = CQtable.Rows[i][7].ToString();
                    ++count2;
                }
                if (CQtable.Rows[i][2].ToString() == "Quasar 670")
                {
                    CqQua670[count3] = CQtable.Rows[i][7].ToString();
                    ++count3;
                }

            }

            for (int i = 0; i < numWells; i++)
            {
                if (CQtable.Rows[i][4].ToString() == "Neg Ctrl")
                    NECindex = i;
                if (CQtable.Rows[i][4].ToString() == "Pos Ctrl")
                    PCTindex = i;
            }
            //LOADING THE CQ TABLE - END --------------------------------------------------------------------------

            //LOADING THE Quasar 670 AMPLIFICATION TABLE  - START --------------------------------------------------------
            for (int i = 0; i < ampFilePaths.Length; i++)
                if (ampFilePaths[i].IndexOf("Quasar 670") != -1)
                    tempFilePath = ampFilePaths[i];
            using (var reader = new StreamReader(tempFilePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    Qua670table.Load(dr);
                }
            }
            foreach (DataColumn column in Qua670table.Columns)
            {
                column.ReadOnly = false;
            }
            numCycles = Qua670table.Rows.Count;

            for (int i = 0; i < numCycles; i++)
            {
                for (int j = 2; j < Qua670table.Columns.Count; j++)
                {
                    tf1 = Convert.ToSingle(Qua670table.Rows[i][j].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    Qua670table.Rows[i][j] = tf1.ToString(); //Quasar 670 RFU values
                }
            }
            //LOADING THE Quasar 670 AMPLIFICATION TABLE - END ------------------------------------------------------------

            //LOADING THE FAM AMPLIFICATION TABLE  - START ---------------------------------------------------------
            for (int i = 0; i < ampFilePaths.Length; i++)
                if (ampFilePaths[i].IndexOf("FAM") != -1)
                    tempFilePath = ampFilePaths[i];
            using (var reader = new StreamReader(tempFilePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    FAMtable.Load(dr);
                }
            }
            foreach (DataColumn column in FAMtable.Columns)
            {
                column.ReadOnly = false;
            }

            for (int i = 0; i < numCycles; i++)
            {
                for (int j = 2; j < FAMtable.Columns.Count; j++)
                {
                    tf1 = Convert.ToSingle(FAMtable.Rows[i][j].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    FAMtable.Rows[i][j] = tf1.ToString(); //FAM RFU values
                }
            }
            //LOADING THE FAM AMPLIFICATION TABLE - END ------------------------------------------------------------

            //LOADING THE HEX AMPLIFICATION TABLE  - START -----------------------------------------------------------
            for (int i = 0; i < ampFilePaths.Length; i++)
                if (ampFilePaths[i].IndexOf("HEX") != -1)
                    tempFilePath = ampFilePaths[i];
            using (var reader = new StreamReader(tempFilePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    HEXtable.Load(dr);
                }
            }
            foreach (DataColumn column in HEXtable.Columns)
            {
                column.ReadOnly = false;
            }

            for (int i = 0; i < numCycles; i++)
            {
                for (int j = 2; j < HEXtable.Columns.Count; j++)
                {
                    tf1 = Convert.ToSingle(HEXtable.Rows[i][j].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    HEXtable.Rows[i][j] = tf1.ToString(); //HEX RFU values
                }
            }
            //LOADING THE HEX AMPLIFICATION TABLE - END -----------------------------------------------------------------

            //LOADING THE Cal Red 610 AMPLIFICATION TABLE - START ---------------------------------------------------------------
            for (int i = 0; i < ampFilePaths.Length; i++)
                if (ampFilePaths[i].IndexOf("Cal Red 610") != -1)
                    tempFilePath = ampFilePaths[i];
            using (var reader = new StreamReader(tempFilePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    CR610table.Load(dr);
                }
            }
            foreach (DataColumn column in CR610table.Columns)
            {
                column.ReadOnly = false;
            }

            for (int i = 0; i < numCycles; i++)
            {
                for (int j = 2; j < CR610table.Columns.Count; j++)
                {
                    tf1 = Convert.ToSingle(CR610table.Rows[i][j].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    CR610table.Rows[i][j] = tf1.ToString(); //Cal Red 610 RFU values
                }
            }
            //LOADING THE Cal Red 610 AMPLIFICATION TABLE - END ----------------------------------------------------------------

            //CREATING THE OBJECT OF Data_KHB AND Well_KHB WITH ALL THE TEST DATA - START -------------------------------
            pcrRunData = new Data_AllPlex(numCycles, numWells);
            pcrRunData.NEC_PCT_results = new Control_AllPlex();
            Control_AllPlex control = new Control_AllPlex();
            pcrRunData.pcrSerial = PCRserial;
            pcrRunData.runDate = outputFileName.Substring(5, 10);
            pcrRunData.runTime = outputFileName.Substring(16, 8);
            control.NEC_hexCq = CqHEX[NECindex]; control.PCT_hexCq = CqHEX[PCTindex];
            control.NEC_famCq = CqFAM[NECindex]; control.PCT_famCq = CqFAM[PCTindex];
            control.NEC_cr610Cq = CqCR610[NECindex]; control.PCT_cr610Cq = CqCR610[PCTindex];
            control.NEC_qua670Cq = CqQua670[NECindex]; control.PCT_qua670Cq = CqQua670[PCTindex];

            tf1 = (Convert.ToSingle(Qua670table.Rows[numCycles - 1][NECindex + 2])
                  + Convert.ToSingle(Qua670table.Rows[numCycles - 2][NECindex + 2])
                  + Convert.ToSingle(Qua670table.Rows[numCycles - 3][NECindex + 2])) / 3;
            control.NEC_qua670RFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(Qua670table.Rows[numCycles - 1][PCTindex + 2])
                  + Convert.ToSingle(Qua670table.Rows[numCycles - 2][PCTindex + 2])
                  + Convert.ToSingle(Qua670table.Rows[numCycles - 3][PCTindex + 2])) / 3;
            control.PCT_qua670RFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(FAMtable.Rows[numCycles - 1][NECindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 2][NECindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 3][NECindex + 2])) / 3;
            control.NEC_famRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(FAMtable.Rows[numCycles - 1][PCTindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 2][PCTindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 3][PCTindex + 2])) / 3;
            control.PCT_famRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(HEXtable.Rows[numCycles - 1][NECindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 2][NECindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 3][NECindex + 2])) / 3;
            control.NEC_hexRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(HEXtable.Rows[numCycles - 1][PCTindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 2][PCTindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 3][PCTindex + 2])) / 3;
            control.PCT_hexRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(CR610table.Rows[numCycles - 1][NECindex + 2])
                  + Convert.ToSingle(CR610table.Rows[numCycles - 2][NECindex + 2])
                  + Convert.ToSingle(CR610table.Rows[numCycles - 3][NECindex + 2])) / 3;
            control.NEC_cr610RFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(CR610table.Rows[numCycles - 1][PCTindex + 2])
                  + Convert.ToSingle(CR610table.Rows[numCycles - 2][PCTindex + 2])
                  + Convert.ToSingle(CR610table.Rows[numCycles - 3][PCTindex + 2])) / 3;
            control.PCT_cr610RFU_endpoint = (float)Math.Round(tf1, 2);

            // PCT and NEC test results logic - by default the PCT and NEC tests are initialized as "SUCCESS"
            if (control.NEC_hexCq == "NaN") // NEC fails if no amplification is found in HEX
                control.NECresult = "FAIL";
            else
            {
                tf1 = Convert.ToSingle(control.NEC_hexCq);
                if (tf1 > 40) // NEC fails if Cq for HEX is more than 40
                    control.NECresult = "FAIL";
                else if (control.NEC_qua670RFU_endpoint >= 999) // NEC fails if amplification is found in Quasar 670
                    control.NECresult = "FAIL";
                else if (control.NEC_famRFU_endpoint >= 999) // NEC fails if amplification is found in FAM
                    control.NECresult = "FAIL";
                else if (control.NEC_cr610RFU_endpoint >= 999) // NEC fails if amplification is found in Cal Red 610
                    control.NECresult = "FAIL";
            }

            if (control.PCT_qua670Cq == "NaN" || control.PCT_famCq == "NaN" || control.PCT_cr610Cq == "NaN") // PCT fails if no amplification is found in any one channel
                control.PCTresult = "FAIL";
            else
            {
                tf1 = Convert.ToSingle(control.PCT_qua670Cq);
                tf2 = Convert.ToSingle(control.PCT_famCq);
                tf3 = Convert.ToSingle(control.PCT_cr610Cq);
                if (tf1 > 40 | tf2 > 40 | tf3 > 40) // PCT fails if Cq value is more than 40 for any one channel
                    control.PCTresult = "FAIL";
                else if (control.PCT_qua670RFU_endpoint < 999 || control.PCT_famRFU_endpoint < 999 || control.PCT_cr610RFU_endpoint < 999) // PCT fails if amplification in any one channel is weak or non-existent
                    control.PCTresult = "FAIL";
            }

            for (int i = 0; i < numWells; i++) // loop for creating and initializing all wells
                pcrRunData.Wells.Add(new Well_AllPlex(numCycles));

            count = 0;
            foreach (Well_AllPlex aWell in pcrRunData.Wells)
            {
                aWell.wellNum = CQtable.Rows[count][1].ToString();
                aWell.wellContent = CQtable.Rows[count][4].ToString();
                aWell.qua670Cq = CqQua670[count];
                aWell.famCq = CqFAM[count];
                aWell.hexCq = CqHEX[count];
                aWell.cr610Cq = CqCR610[count];

                tf1 = (Convert.ToSingle(Qua670table.Rows[numCycles - 1][count + 2])
                  + Convert.ToSingle(Qua670table.Rows[numCycles - 2][count + 2])
                  + Convert.ToSingle(Qua670table.Rows[numCycles - 3][count + 2])) / 3;
                aWell.qua670RFU_endpoint = (float)Math.Round(tf1, 2);

                tf1 = (Convert.ToSingle(FAMtable.Rows[numCycles - 1][count + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 2][count + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 3][count + 2])) / 3;
                aWell.famRFU_endpoint = (float)Math.Round(tf1, 2);

                tf1 = (Convert.ToSingle(HEXtable.Rows[numCycles - 1][count + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 2][count + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 3][count + 2])) / 3;
                aWell.hexRFU_endpoint = (float)Math.Round(tf1, 2);

                tf1 = (Convert.ToSingle(CR610table.Rows[numCycles - 1][count + 2])
                  + Convert.ToSingle(CR610table.Rows[numCycles - 2][count + 2])
                  + Convert.ToSingle(CR610table.Rows[numCycles - 3][count + 2])) / 3;
                aWell.cr610RFU_endpoint = (float)Math.Round(tf1, 2);

                for (int i = 0; i < numCycles; i++)
                {
                    aWell.qua670RFU_points[i] = Convert.ToSingle(Qua670table.Rows[i][count + 2]);
                    aWell.famRFU_points[i] = Convert.ToSingle(FAMtable.Rows[i][count + 2]);
                    aWell.hexRFU_points[i] = Convert.ToSingle(HEXtable.Rows[i][count + 2]);
                    aWell.cr610RFU_points[i] = Convert.ToSingle(CR610table.Rows[i][count + 2]);
                }
                //-----test call logic for each well - by default, the well sample is considered a "(-) neg"
                if (control.NECresult == "FAIL" || control.PCTresult == "FAIL")
                    aWell.test_call = "Inconclusive";
                else
                {
                    count1 = 0;
                    if (aWell.qua670Cq != "NaN")
                        if (aWell.qua670RFU_endpoint > 999) ++count1;
                    if (aWell.famCq != "NaN")
                        if (aWell.famRFU_endpoint > 999) ++count1;
                    if (aWell.cr610Cq != "NaN")
                        if (aWell.cr610RFU_endpoint > 999) ++count1;
                    switch (count1)
                    {
                        case 0:
                            if (aWell.hexCq == "NaN")
                                aWell.test_call = "Inconclusive";
                            break;
                        case 1:
                            aWell.test_call = "(+) POSITIVE";
                            break;
                        case 2:
                            aWell.test_call = "(+) POSITIVE";
                            break;
                        case 3:
                            aWell.test_call = "(+) POSITIVE";
                            break;
                        default:
                            break;
                    }
                }
                ++count;
            }
            pcrRunData.NEC_PCT_results = control;
            //CREATING THE OBJECT OF Data_PrimerDesign AND Well_PrimerDesign WITH ALL THE TEST DATA - END ---------------


            //WRITING THE JSON FILE - START ------------------------------------------------------------------------------
            jsonText = JsonConvert.SerializeObject(pcrRunData, Formatting.Indented);
            File.WriteAllText(jsonResultFilePath, jsonText, Encoding.UTF8);
            //WRITING THE JSON FILE - END --------------------------------------------------------------------------------


            //DELETING THE CSV FILES AND CLEARING THE TABLES - START -----------------------------------------------------
            string[] filePaths = Directory.GetFiles(csvFilesFolder, "*.csv");
            for (int i = 0; i < filePaths.Length; i++)
                File.Delete(filePaths[i]);
            Qua670table.Clear();
            HEXtable.Clear();
            FAMtable.Clear();
            CR610table.Clear();
            CQtable.Clear();
            //DELETING THE CSV FILES AND CLEARING THE TABLES - END -------------------------------------------------------
        }








        static void process_data_KHB(string PCRserial, string outputFileName)
        {
            Data_KHB pcrRunData;
            int numCycles, numWells, count = 0, count1 = 0, count2 = 0, count3 = 0, NECindex = 0, PCTindex = 9;
            float tf1, tf2, tf3;
            DataTable FAMtable = new DataTable();
            DataTable HEXtable = new DataTable();
            DataTable ROXtable = new DataTable();
            DataTable Cy5table = new DataTable();
            DataTable CQtable = new DataTable();
            string ampFileSubstring = outputFileName + " -  Quantification Amplification*.csv";
            string[] ampFilePaths = Directory.GetFiles(csvFilesFolder, ampFileSubstring);
            string CqFileSubstring = outputFileName + " -  Quantification Cq*.csv";
            string[] CqFilePath = Directory.GetFiles(csvFilesFolder, CqFileSubstring);
            string[] CqFAM, CqHEX, CqROX, CqCy5;
            string jsonText, tempFilePath = ampFilePaths[0];
            string jsonResultFileName = string.Format("{0}_{1}_{2}", PCRserial, outputFileName, "Result.json");
            string jsonResultFilePath = Path.Combine(jsonResultFileFolder, jsonResultFileName);

            //LOADING THE CQ TABLE - START ------------------------------------------------------------------------
            using (var reader = new StreamReader(CqFilePath[0]))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    CQtable.Load(dr);
                }
            }
            foreach (DataColumn column in CQtable.Columns)
            {
                column.ReadOnly = false;
            }
            numWells = CQtable.Rows.Count / 4;
            CqFAM = new string[numWells];
            CqHEX = new string[numWells];
            CqROX = new string[numWells];
            CqCy5 = new string[numWells];

            count = 0; count1 = 0; count2 = 0; count3 = 0;
            for (int i = 0; i < CQtable.Rows.Count; i++)
            {
                if (CQtable.Rows[i][7].ToString() != "NaN")
                {
                    tf1 = Convert.ToSingle(CQtable.Rows[i][7].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    CQtable.Rows[i][7] = tf1.ToString();
                }
                if (CQtable.Rows[i][2].ToString() == "FAM")
                {
                    CqFAM[count] = CQtable.Rows[i][7].ToString();
                    ++count;
                }
                if (CQtable.Rows[i][2].ToString() == "HEX")
                {
                    CqHEX[count1] = CQtable.Rows[i][7].ToString();
                    ++count1;
                }
                if (CQtable.Rows[i][2].ToString() == "ROX")
                {
                    CqROX[count2] = CQtable.Rows[i][7].ToString();
                    ++count2;
                }
                if (CQtable.Rows[i][2].ToString() == "Cy5")
                {
                    CqCy5[count3] = CQtable.Rows[i][7].ToString();
                    ++count3;
                }

            }

            for (int i = 0; i < numWells; i++)
            {
                if (CQtable.Rows[i][4].ToString() == "Neg Ctrl")
                    NECindex = i;
                if (CQtable.Rows[i][4].ToString() == "Pos Ctrl")
                    PCTindex = i;
            }
            //LOADING THE CQ TABLE - END --------------------------------------------------------------------------

            //LOADING THE Cy5 AMPLIFICATION TABLE  - START --------------------------------------------------------
            for (int i = 0; i < ampFilePaths.Length; i++)
                if (ampFilePaths[i].IndexOf("Cy5") != -1)
                    tempFilePath = ampFilePaths[i];
            using (var reader = new StreamReader(tempFilePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    Cy5table.Load(dr);
                }
            }
            foreach (DataColumn column in Cy5table.Columns)
            {
                column.ReadOnly = false;
            }
            numCycles = Cy5table.Rows.Count;

            for (int i = 0; i < numCycles; i++)
            {
                for (int j = 2; j < Cy5table.Columns.Count; j++)
                {
                    tf1 = Convert.ToSingle(Cy5table.Rows[i][j].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    Cy5table.Rows[i][j] = tf1.ToString(); //Cy5 RFU values
                }
            }
            //LOADING THE Cy5 AMPLIFICATION TABLE - END ------------------------------------------------------------

            //LOADING THE FAM AMPLIFICATION TABLE  - START ---------------------------------------------------------
            for (int i = 0; i < ampFilePaths.Length; i++)
                if (ampFilePaths[i].IndexOf("FAM") != -1)
                    tempFilePath = ampFilePaths[i];
            using (var reader = new StreamReader(tempFilePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    FAMtable.Load(dr);
                }
            }
            foreach (DataColumn column in FAMtable.Columns)
            {
                column.ReadOnly = false;
            }

            for (int i = 0; i < numCycles; i++)
            {
                for (int j = 2; j < FAMtable.Columns.Count; j++)
                {
                    tf1 = Convert.ToSingle(FAMtable.Rows[i][j].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    FAMtable.Rows[i][j] = tf1.ToString(); //FAM RFU values
                }
            }
            //LOADING THE FAM AMPLIFICATION TABLE - END ------------------------------------------------------------

            //LOADING THE HEX AMPLIFICATION TABLE  - START -----------------------------------------------------------
            for (int i = 0; i < ampFilePaths.Length; i++)
                if (ampFilePaths[i].IndexOf("HEX") != -1)
                    tempFilePath = ampFilePaths[i];
            using (var reader = new StreamReader(tempFilePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    HEXtable.Load(dr);
                }
            }
            foreach (DataColumn column in HEXtable.Columns)
            {
                column.ReadOnly = false;
            }

            for (int i = 0; i < numCycles; i++)
            {
                for (int j = 2; j < HEXtable.Columns.Count; j++)
                {
                    tf1 = Convert.ToSingle(HEXtable.Rows[i][j].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    HEXtable.Rows[i][j] = tf1.ToString(); //HEX RFU values
                }
            }
            //LOADING THE HEX AMPLIFICATION TABLE - END -----------------------------------------------------------------

            //LOADING THE ROX AMPLIFICATION TABLE - START ---------------------------------------------------------------
            for (int i = 0; i < ampFilePaths.Length; i++)
                if (ampFilePaths[i].IndexOf("ROX") != -1)
                    tempFilePath = ampFilePaths[i];
            using (var reader = new StreamReader(tempFilePath))
            using (var csv = new CsvReader(reader, CultureInfo.InvariantCulture))
            {
                using (var dr = new CsvDataReader(csv))
                {
                    ROXtable.Load(dr);
                }
            }
            foreach (DataColumn column in ROXtable.Columns)
            {
                column.ReadOnly = false;
            }

            for (int i = 0; i < numCycles; i++)
            {
                for (int j = 2; j < ROXtable.Columns.Count; j++)
                {
                    tf1 = Convert.ToSingle(ROXtable.Rows[i][j].ToString());
                    tf1 = (float)Math.Round(tf1, 2);
                    ROXtable.Rows[i][j] = tf1.ToString(); //ROX RFU values
                }
            }
            //LOADING THE ROX AMPLIFICATION TABLE - END ----------------------------------------------------------------

            //CREATING THE OBJECT OF Data_KHB AND Well_KHB WITH ALL THE TEST DATA - START -------------------------------
            pcrRunData = new Data_KHB(numCycles, numWells);
            Control_KHB control = new Control_KHB();
            pcrRunData.NEC_PCT_results = new Control_KHB();
            pcrRunData.pcrSerial = PCRserial;
            pcrRunData.runDate = outputFileName.Substring(5, 10);
            pcrRunData.runTime = outputFileName.Substring(16, 8);
            control.NEC_hexCq = CqHEX[NECindex]; control.PCT_hexCq = CqHEX[PCTindex];
            control.NEC_famCq = CqFAM[NECindex]; control.PCT_famCq = CqFAM[PCTindex];
            control.NEC_roxCq = CqROX[NECindex]; control.PCT_roxCq = CqROX[PCTindex];
            control.NEC_cy5Cq = CqCy5[NECindex]; control.PCT_cy5Cq = CqCy5[PCTindex];

            tf1 = (Convert.ToSingle(Cy5table.Rows[numCycles - 1][NECindex + 2])
                  + Convert.ToSingle(Cy5table.Rows[numCycles - 2][NECindex + 2])
                  + Convert.ToSingle(Cy5table.Rows[numCycles - 3][NECindex + 2])) / 3;
            control.NEC_cy5RFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(Cy5table.Rows[numCycles - 1][PCTindex + 2])
                  + Convert.ToSingle(Cy5table.Rows[numCycles - 2][PCTindex + 2])
                  + Convert.ToSingle(Cy5table.Rows[numCycles - 3][PCTindex + 2])) / 3;
            control.PCT_cy5RFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(FAMtable.Rows[numCycles - 1][NECindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 2][NECindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 3][NECindex + 2])) / 3;
            control.NEC_famRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(FAMtable.Rows[numCycles - 1][PCTindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 2][PCTindex + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 3][PCTindex + 2])) / 3;
            control.PCT_famRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(HEXtable.Rows[numCycles - 1][NECindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 2][NECindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 3][NECindex + 2])) / 3;
            control.NEC_hexRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(HEXtable.Rows[numCycles - 1][PCTindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 2][PCTindex + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 3][PCTindex + 2])) / 3;
            control.PCT_hexRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(ROXtable.Rows[numCycles - 1][NECindex + 2])
                  + Convert.ToSingle(ROXtable.Rows[numCycles - 2][NECindex + 2])
                  + Convert.ToSingle(ROXtable.Rows[numCycles - 3][NECindex + 2])) / 3;
            control.NEC_roxRFU_endpoint = (float)Math.Round(tf1, 2);

            tf1 = (Convert.ToSingle(ROXtable.Rows[numCycles - 1][PCTindex + 2])
                  + Convert.ToSingle(ROXtable.Rows[numCycles - 2][PCTindex + 2])
                  + Convert.ToSingle(ROXtable.Rows[numCycles - 3][PCTindex + 2])) / 3;
            control.PCT_roxRFU_endpoint = (float)Math.Round(tf1, 2);

            // NEC test results logic - by default the NEC is initialized as "SUCCESS"
            if (control.NEC_famCq != "NaN")
            {
                if (Convert.ToSingle(control.NEC_famCq) <= 40 && Convert.ToSingle(control.NEC_famCq) > 15)
                    if (control.NEC_famRFU_endpoint >= 999) control.NECresult = "FAIL";
            }
            if (control.NEC_roxCq != "NaN")
            {
                if (Convert.ToSingle(control.NEC_roxCq) <= 40 && Convert.ToSingle(control.NEC_roxCq) > 15)
                    if (control.NEC_roxRFU_endpoint >= 999) control.NECresult = "FAIL";
            }
            if (control.NEC_cy5Cq != "NaN")
            {
                if (Convert.ToSingle(control.NEC_cy5Cq) <= 40 && Convert.ToSingle(control.NEC_cy5Cq) > 15)
                    if (control.NEC_cy5RFU_endpoint >= 999) control.NECresult = "FAIL";
            }


            // PCT test results logic - by default the PCT is initialized as "FAIL"
            count1 = 0;
            if (control.PCT_famCq != "NaN")
            {
                if (Convert.ToSingle(control.PCT_famCq) <= 40 && Convert.ToSingle(control.PCT_famCq) > 15)
                    if (control.PCT_famRFU_endpoint >= 999) ++count1;
            }
            if (control.PCT_roxCq != "NaN")
            {
                if (Convert.ToSingle(control.PCT_roxCq) <= 40 && Convert.ToSingle(control.PCT_roxCq) > 15)
                    if (control.PCT_roxRFU_endpoint >= 999) ++count1;
            }
            if (control.PCT_cy5Cq != "NaN")
            {
                if (Convert.ToSingle(control.PCT_cy5Cq) <= 40 && Convert.ToSingle(control.PCT_cy5Cq) > 15)
                    if (control.PCT_cy5RFU_endpoint >= 999) ++count1;
            }
            if (count1 > 0)
                control.PCTresult = "SUCCESS";
            else
                control.PCTresult = "FAIL"; // Already initialized PCTresult as "FAIL", but just in case


            for (int i = 0; i < numWells; i++) // loop for creating and initializing all wells
                pcrRunData.Wells.Add(new Well_KHB(numCycles));

            // Populating the well objects with data
            count = 0;
            foreach (Well_KHB aWell in pcrRunData.Wells)
            {
                aWell.wellNum = CQtable.Rows[count][1].ToString();
                aWell.wellContent = CQtable.Rows[count][4].ToString();
                aWell.cy5Cq = CqCy5[count];
                aWell.famCq = CqFAM[count];
                aWell.hexCq = CqHEX[count];
                aWell.roxCq = CqROX[count];

                tf1 = (Convert.ToSingle(Cy5table.Rows[numCycles - 1][count + 2])
                  + Convert.ToSingle(Cy5table.Rows[numCycles - 2][count + 2])
                  + Convert.ToSingle(Cy5table.Rows[numCycles - 3][count + 2])) / 3;
                aWell.cy5RFU_endpoint = (float)Math.Round(tf1, 2);

                tf1 = (Convert.ToSingle(FAMtable.Rows[numCycles - 1][count + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 2][count + 2])
                  + Convert.ToSingle(FAMtable.Rows[numCycles - 3][count + 2])) / 3;
                aWell.famRFU_endpoint = (float)Math.Round(tf1, 2);

                tf1 = (Convert.ToSingle(HEXtable.Rows[numCycles - 1][count + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 2][count + 2])
                  + Convert.ToSingle(HEXtable.Rows[numCycles - 3][count + 2])) / 3;
                aWell.hexRFU_endpoint = (float)Math.Round(tf1, 2);

                tf1 = (Convert.ToSingle(ROXtable.Rows[numCycles - 1][count + 2])
                  + Convert.ToSingle(ROXtable.Rows[numCycles - 2][count + 2])
                  + Convert.ToSingle(ROXtable.Rows[numCycles - 3][count + 2])) / 3;
                aWell.roxRFU_endpoint = (float)Math.Round(tf1, 2);

                for (int i = 0; i < numCycles; i++)
                {
                    aWell.cy5RFU_points[i] = Convert.ToSingle(Cy5table.Rows[i][count + 2]);
                    aWell.famRFU_points[i] = Convert.ToSingle(FAMtable.Rows[i][count + 2]);
                    aWell.hexRFU_points[i] = Convert.ToSingle(HEXtable.Rows[i][count + 2]);
                    aWell.roxRFU_points[i] = Convert.ToSingle(ROXtable.Rows[i][count + 2]);
                }
                //-----test call logic for each well - by default, the well sample is considered a "(-) neg"
                if (control.NECresult == "FAIL" || control.PCTresult == "FAIL")
                    aWell.test_call = "Inconclusive";
                else
                {
                    count1 = 0;
                    if (aWell.cy5Cq != "NaN")
                        if (aWell.cy5RFU_endpoint >= 1000) ++count1;
                    if (aWell.famCq != "NaN")
                        if (aWell.famRFU_endpoint >= 1000) ++count1;
                    if (aWell.roxCq != "NaN")
                        if (aWell.roxRFU_endpoint >= 1000) ++count1;
                    switch (count1)
                    {
                        case 0:
                            if (aWell.hexCq == "NaN")
                                aWell.test_call = "Inconclusive";
                            break;
                        case 1:
                            aWell.test_call = "Inconclusive";
                            break;
                        case 2:
                            aWell.test_call = "(+) POSITIVE";
                            break;
                        case 3:
                            aWell.test_call = "(+) POSITIVE";
                            break;
                        default:
                            break;
                    }
                }
                ++count;
            }
            pcrRunData.NEC_PCT_results = control;
            // write the overall_test_result logic here
            //CREATING THE OBJECT OF Data_PrimerDesign AND Well_PrimerDesign WITH ALL THE TEST DATA - END ---------------


            //WRITING THE JSON FILE - START ------------------------------------------------------------------------------
            jsonText = JsonConvert.SerializeObject(pcrRunData, Formatting.Indented);
            File.WriteAllText(jsonResultFilePath, jsonText, Encoding.UTF8);
            //WRITING THE JSON FILE - END --------------------------------------------------------------------------------


            //DELETING THE CSV FILES AND CLEARING THE TABLES - START -----------------------------------------------------
            string[] filePaths = Directory.GetFiles(csvFilesFolder, "*.csv");
            for (int i = 0; i < filePaths.Length; i++)
                File.Delete(filePaths[i]);
            Cy5table.Clear();
            HEXtable.Clear();
            FAMtable.Clear();
            ROXtable.Clear();
            CQtable.Clear();
            //DELETING THE CSV FILES AND CLEARING THE TABLES - END -------------------------------------------------------
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
        }
    }
}
